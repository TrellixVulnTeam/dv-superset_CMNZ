{"ast":null,"code":"import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _trimInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/trim\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _flatMapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/flat-map\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Find Option value that matches a possibly string value.\n *\n * Translate possible string values to `OptionType` objects, fallback to value\n * itself if cannot be found in the options list.\n *\n * Always returns an array.\n */\nexport function findValue(value, options = [], valueKey = 'value') {var _context;\n  if (value === null || value === undefined || value === '') {\n    return [];\n  }\n  const isGroup = _Array$isArray((options[0] || {}).options);\n  const flatOptions = isGroup ?\n  _flatMapInstanceProperty(options).call(options, (x) => x.options || []) :\n  options;\n  const find = (val) => {\n    const realVal = (value || {}).hasOwnProperty(valueKey) ?\n    val[valueKey] :\n    val;\n    return _findInstanceProperty(flatOptions).call(flatOptions, (x) => x === realVal || x[valueKey] === realVal) || val;\n  };\n  // If value is a single string, must return an Array so `cleanValue` won't be\n  // empty: https://github.com/JedWatson/react-select/blob/32ad5c040bdd96cd1ca71010c2558842d684629c/packages/react-select/src/utils.js#L64\n  return _mapInstanceProperty(_context = _Array$isArray(value) ? value : [value]).call(_context, find);\n}\nexport function hasOption(search, options) {\n  const searchOption = _trimInstanceProperty(search).call(search).toLowerCase();\n  return _findInstanceProperty(options).call(options, (opt) => {var _context2, _context3;\n    const { label, value } = opt;\n    const labelText = String(label);\n    const valueText = String(value);\n    return _includesInstanceProperty(_context2 = valueText.toLowerCase()).call(_context2, searchOption) ||\n    _includesInstanceProperty(_context3 = labelText.toLowerCase()).call(_context3, searchOption);\n  });\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(findValue, \"findValue\", \"/Users/frankhe/projects/superset/superset-frontend/src/components/Select/utils.ts\");reactHotLoader.register(hasOption, \"hasOption\", \"/Users/frankhe/projects/superset/superset-frontend/src/components/Select/utils.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/Users/frankhe/projects/superset/superset-frontend/src/components/Select/utils.ts"],"names":[],"mappings":"+zBA2BA;;;;;;;AAOG;AACH,OAAM,SAAU,SAAV,CACJ,KADI,EAEJ,OAAA,GAAoE,EAFhE,EAGJ,QAAQ,GAAG,OAHP,EAGc;AAElB,MAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,SAA5B,IAAyC,KAAK,KAAK,EAAvD,EAA2D;AACzD,WAAO,EAAP;AACD;AACD,QAAM,OAAO,GAAG,eAAc,CAAC,OAAO,CAAC,CAAD,CAAP,IAAc,EAAf,EAAmB,OAAjC,CAAhB;AACA,QAAM,WAAW,GAAG,OAAO;AACtB,2BAAA,OAA0C,MAA1C,CAAA,OAA0C,EAAS,CAAA,CAAC,KAAI,CAAC,CAAC,OAAF,IAAa,EAA3B,CADpB;AAEtB,EAAA,OAFL;AAIA,QAAM,IAAI,GAAG,CAAC,GAAD,KAAoB;AAC/B,UAAM,OAAO,GAAG,CAAC,KAAK,IAAI,EAAV,EAAc,cAAd,CAA6B,QAA7B;AACZ,IAAA,GAAG,CAAC,QAAD,CADS;AAEZ,IAAA,GAFJ;AAGA,WACE,sBAAA,WAAW,MAAX,CAAA,WAAW,EAAM,CAAA,CAAC,KAAI,CAAC,KAAK,OAAN,IAAiB,CAAC,CAAC,QAAD,CAAD,KAAgB,OAA5C,CAAX,IAAmE,GADrE;AAGD,GAPD;AASA;AACA;AACA,SAAO,gCAAC,eAAc,KAAd,IAAuB,KAAvB,GAA+B,CAAC,KAAD,CAAhC,iBAA6C,IAA7C,CAAP;AACD;AAED,OAAM,SAAU,SAAV,CAAoB,MAApB,EAAoC,OAApC,EAA4D;AAChE,QAAM,YAAY,GAAG,sBAAA,MAAM,MAAN,CAAA,MAAM,EAAQ,WAAd,EAArB;AACA,SAAO,sBAAA,OAAO,MAAP,CAAA,OAAO,EAAM,CAAA,GAAG,KAAG;AACxB,UAAM,EAAE,KAAF,EAAS,KAAT,KAAmB,GAAzB;AACA,UAAM,SAAS,GAAG,MAAM,CAAC,KAAD,CAAxB;AACA,UAAM,SAAS,GAAG,MAAM,CAAC,KAAD,CAAxB;AACA,WACE,sCAAA,SAAS,CAAC,WAAV,oBAAiC,YAAjC;AACA,0CAAA,SAAS,CAAC,WAAV,oBAAiC,YAAjC,CAFF;AAID,GARa,CAAd;AASD,C,iLAtCe,S,4HA2BA,S","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  OptionTypeBase,\n  ValueType,\n  OptionsType,\n  GroupedOptionsType,\n} from 'react-select';\n\nimport { OptionsType as AntdOptionsType } from './Select';\n\n/**\n * Find Option value that matches a possibly string value.\n *\n * Translate possible string values to `OptionType` objects, fallback to value\n * itself if cannot be found in the options list.\n *\n * Always returns an array.\n */\nexport function findValue<OptionType extends OptionTypeBase>(\n  value: ValueType<OptionType> | string,\n  options: GroupedOptionsType<OptionType> | OptionsType<OptionType> = [],\n  valueKey = 'value',\n): OptionType[] {\n  if (value === null || value === undefined || value === '') {\n    return [];\n  }\n  const isGroup = Array.isArray((options[0] || {}).options);\n  const flatOptions = isGroup\n    ? (options as GroupedOptionsType<OptionType>).flatMap(x => x.options || [])\n    : (options as OptionsType<OptionType>);\n\n  const find = (val: OptionType) => {\n    const realVal = (value || {}).hasOwnProperty(valueKey)\n      ? val[valueKey]\n      : val;\n    return (\n      flatOptions.find(x => x === realVal || x[valueKey] === realVal) || val\n    );\n  };\n\n  // If value is a single string, must return an Array so `cleanValue` won't be\n  // empty: https://github.com/JedWatson/react-select/blob/32ad5c040bdd96cd1ca71010c2558842d684629c/packages/react-select/src/utils.js#L64\n  return (Array.isArray(value) ? value : [value]).map(find);\n}\n\nexport function hasOption(search: string, options: AntdOptionsType) {\n  const searchOption = search.trim().toLowerCase();\n  return options.find(opt => {\n    const { label, value } = opt;\n    const labelText = String(label);\n    const valueText = String(value);\n    return (\n      valueText.toLowerCase().includes(searchOption) ||\n      labelText.toLowerCase().includes(searchOption)\n    );\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}